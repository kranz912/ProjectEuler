# ProjectEuler
Solving Euler problems

Project Euler is a series of challenging mathematical/computer programming problems that will require more than just mathematical insights to solve. Although mathematics will help you arrive at elegant and efficient methods, the use of a computer and programming skills will be required to solve most problems. (https://projecteuler.net/about)

I will be using python for this challenge

### Problem 1: 	Multiples of 3 and 5
If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
Find the sum of all the multiples of 3 or 5 below 1000.

```python
sum =0;
for x in range(3,1000):
    if(x%3==0 or x%5 == 0):
        sum+=x
print(sum)
```
### Problem 2: 	Even Fibonacci numbers
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

```python
numbers=[1,1];
x=0;
sum=0
while(True):
    if(x!=0):
        n= numbers[x] + numbers[x-1]
        if (n > 4 * 10 ** 6):
            break
        numbers.append(n)
        if(n%2==0):
            sum+=n;
    x += 1
print(sum)
```
the solution above can be solved using a recursive function for computing the fibbonaci value of n, but since it will be ineffienct having O(n^2) runtime. I used an array to store the previous numbers to have O(n) runtime but having additional space of O(n).

### Problem 3: Largest prime factor
The prime factors of 13195 are 5, 7, 13 and 29.
What is the largest prime factor of the number 600851475143 ?

```python
import math
def getprimefactors(x):
    largest=1
    while(x%2==0):
        x=x/2
        largest=2
    for i in range(3,int(math.sqrt(x)),2):
        while(x%i==0):
            largest=i
            x=x/i
    x=int(x)
    if(x>2):
        largest=x
    return largest
print(getprimefactors(13195))
```

Since we continue to divide the input the solution has a runtime of O(log n).
example:
```python
x=8
x/2 = 4 largest= 2
x/2 = 2 largest =2
x/2 = 1 largest =2
```
we only incremented 3 times in this case and log 8 base 2 is = 3

### Problem 4: 	Largest palindrome product
A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 Ã— 99.
Find the largest palindrome made from the product of two 3-digit numbers.
#### Solution 1
```python
def CheckIfNumberIsPalindrome(x):
    Reverse=0
    Number=x
    while(Number>0):
        Reminder = Number%10
        Reverse = (Reverse *10) + Reminder
        Number= Number//10
    return x==Reverse
def getLargestPalindrome(min,max):
    largest=0
    for x in range(min,max):
        for y in range(min,max):
            product= y*x
            isPalindrome = CheckIfNumberIsPalindrome(product)
            if(isPalindrome):
                if(product>largest):
                    largest= product
    return largest
print(getLargestPalindrome(100,1000))
```
the above solution is slower since it checks the digits twice. ex y=200 x=300 y*x =600, and y=300 x=200 y\*x= 600
reversing the digits when checking if it is a palindrome will have a runtime complexity of O(k) where k is the number of digits.
Instead we can convert it to a string and compare the first element to the last element that way we can have a runtime complexity of O(k/2) which is applied to solution 2.
#### Solution 2
```python
def CheckIfNumberIsPalindrome(x):
    ispalindrome=True
    i=0
    x=str(x)
    while((i<len(x)/2) and ispalindrome):
        if(x[i]!=x[-(i+1)]):
            ispalindrome= False
        i+=1
    return ispalindrome
def getLargestPalindrome(min,max):
    largest=0
    for x in range(max,min,-1):
        for y in range(x,min,-1):
            product= y*x
            if (product > largest):
                isPalindrome = CheckIfNumberIsPalindrome(product)
                if(isPalindrome):
                    largest= product
            else:
                break
    return largest
print(getLargestPalindrome(100,1000))
```

